# this was my original file for the project but the code has now been split out


# libraries ---------------------------------------------------------------



library(tidyverse)
library(openrouteservice)
library(jogger)
library(sf)
library(tmap)


# get MSOA centroids and bind together ------------------------------------




south_names <- c(
  "Bexley",
  "Greenwich",
  "Bromley",
  "Croydon",
  "Southwark",
  "Lambeth",
  "Lewisham",
  "Merton",
  "Sutton",
  "Kingston upon Thames",
  "Richmond upon Thames", # straddles river
  "Wandsworth",
  # ok Hounslow is north of the river but adding to sth to ~equalise MSOA nos.!
  "Hounslow",   # 13
  "Kent",
  "Surrey",
  "East Sussex",
  "West Sussex",
  "Brighton and Hove" # 18
  )


north_names <- c(
  "Havering",
  "Barking and Dagenham",
  "Redbridge",
  "Waltham Forest",
  "Hackney",
  "Haringey",
  "Tower Hamlets",
  "City of London",
  "Newham",
  "Enfield",
  "Islington",
  "Camden",
  "Ealing",
  "Brent",
  "Barnet",
  "Westminster",
  "Kensington and Chelsea",
  "Hammersmith and Fulham",
  "Harrow",
  "Hillingdon", # 20
  "Hertfordshire",
  "Essex",
  "Thurrock",
  "Southend-on-Sea" # 24
  )


north_msoas <- north_names %>%
  map_df( ~ geo_get(
    "msoa",
    .,
    "utla",
    return_centroids = TRUE
  ))



south_msoas <- south_names %>%
  map_df( ~ geo_get(
    "msoa",
    .,
    "utla",
    return_centroids = TRUE
  ))

saveRDS(north_msoas, here::here("rds_data", "north_msoas.Rds"))
saveRDS(south_msoas, here::here("rds_data", "south_msoas.Rds"))




# get LAD centroids and bind together -------------------------------------



north_lads <- north_names %>%
  map_df( ~ geo_get(
    "lad",
    .,
    "utla",
    centroid_fields = TRUE
  )) %>%
  sf::st_drop_geometry() %>%
  dplyr::select(-c(bng_e, bng_n)) %>%
  sf::st_as_sf(coords = c("long", "lat"), crs = 4326)

south_lads <- south_names %>%
  map_df( ~ geo_get(
    "lad",
    .,
    "utla",
    centroid_fields = TRUE
  )) %>%
  sf::st_drop_geometry() %>%
  dplyr::select(-c(bng_e, bng_n)) %>%
  sf::st_as_sf(coords = c("long", "lat"), crs = 4326)


saveRDS(north_lads, here::here("rds_data", "north_lads.Rds"))
saveRDS(south_lads, here::here("rds_data", "south_lads.Rds"))





# create a polygon to represent the crossing ------------------------------


crossing_sf <- sf::st_linestring(
  matrix(
    c(
      0.2519821062, 51.4662165200,  # northwest
      0.2635477915, 51.4662165200,  # northeast
      0.2635477915, 51.4632889186,  # southeast
      0.2519821062, 51.4632889186,  # southwest
      0.2519821062, 51.4662165200), # northwest
    ncol = 2, byrow = TRUE),
) %>%
  sf::st_polygonize() %>%
  sf::st_sfc(crs = 4326)

# crossing_s2 <- s2::s2_make_polygon(
#   longitude = c(0.2519821062, 0.2635477915),
#   latitude = c(51.4632889186, 51.4662165200)
# )


# test it out -------------------------------------------------------------



test <- all_msoas %>%
  dplyr::slice_sample(n = 2)



test_pair <- function(df) {
  df %>%
    sf::st_coordinates() %>%
    ors_directions(output = "sf", radiuses = -1) %>%
    s2::s2_intersects(crossing_sf)
    # sf::st_as_s2() %>%
    # s2::s2_intersects_box(
    #   lng1 = 0.2519821062,
    #   lat1 = 51.4632889186,
    #   lng2 = 0.2635477915,
    #   lat2 = 51.4662165200
    # )
}

test_pair(test)


# functions take 2 --------------------------------------------------------


check_pair <- function(df) {
  df %>%
    sf::st_coordinates() %>%
    ors_directions(output = "sf", radiuses = -1) %>%
    s2::s2_intersects(crossing_sf)
}

pull_cross <- function(df, n, msoa) {
  df %>%
    slice(n) %>%
    bind_rows(msoa, .) %>%
    check_pair()
}

work_down <- function(current_msoa, other_df) {

  crossings <- seq(nrow(other_df)) %>%
    purrr::map_lgl( ~ pull_cross(other_df, ., current_msoa)) %>%
    sum()

  current_msoa %>%
    dplyr::mutate(crossings = crossings)
}

south1 <- south_msoas %>%
  slice(1)
south1_out <- work_down(south1, north_msoas)



# functions take 3 --------------------------------------------------------

check_intersect <- function(a, b, radius = 350) {
  if (radius > 1400) { radius <- -1 }
  list(a, b) %>%
    ors_directions(output = "sf", radiuses = radius) %>%
    s2::s2_intersects(crossing_sf)
}

check_intersect_possibly <- function(a, b, radius = 350) {
  purrr::insistently(
    purrr::possibly(
      .f = check_intersect(a, b, radius),
      otherwise = check_intersect_possibly(a, b, radius = radius + 200)
    )
  )
}


work_down <- function(current_msoa, lads_coords) {

  a <- current_msoa %>%
    sf::st_coordinates() %>%
    `[`(1,)

  crossings <- seq(nrow(coords)) %>%
    purrr::map( ~ dplyr::slice(coords, .) %>% unlist()) %>%
    purrr::map_lgl( ~ check_intersect_possibly(a, .)) %>%
    sum()

  current_msoa %>%
    dplyr::mutate(crossings = crossings) %>%
    dplyr::mutate(of_maximum = nrow(other_df))
}


check_full_list <- function(msoas_list, lads_list) {

  coords <- lads_list %>%
    sf::st_coordinates() %>%
    dplyr::as_tibble()

  msoas_list %>%
    split( ~ msoa11cd) %>%
    purrr::map_df( ~ work_down(., coords))

}


# run as job!
# south_lads_out <- check_full_list(kent_msoas, north_lads)



# functions take 4 --------------------------------------------------------

check_intersect <- function(a, b, radius_a = 250, radius_b = 250) {

  tryCatch(
    {
      list(a, b) %>%
        openrouteservice::ors_directions(output = "sf", instructions = FALSE, suppress_warnings = TRUE, radiuses = c(radius_a, radius_b)) %>%
        dplyr::mutate(radius_a = radius_a) %>%
        dplyr::mutate(radius_b = radius_b) %>%
        dplyr::select(!summary) %>%
        dplyr::mutate(status = "Success") %>%
        dplyr::mutate(crosses = s2::s2_intersects(., crossing_sf)) %>%
        dplyr::relocate(geometry, .after = last_col())
    },

    error = function(cond) {
      probs <- stringr::str_extract_all(
        string = conditionMessage(cond),
        pattern = "(?<=coordinate )[:digit:]+"
      ) %>%
        unlist() %>%
        as.numeric()

      if (length(probs) == 0) {
        dplyr::tribble(
          ~way_points, ~status, ~crosses, ~geometry,
          NA, cond, FALSE, NA
        )
        usethis::ui_warn(cond)
      } else if ( radius_a < 4001 && radius_a < 4001) {
        if (0 %in% probs) {
          radius_a <- radius_a * 2
        }
        if (1 %in% probs) {
          radius_b <- radius_b * 2
        }
        check_intersect(a, b, radius_a, radius_b)
      } else {
        nf_msg <- "Routable point(s) not found"
        dplyr::tribble(
          ~way_points, ~status, ~crosses, ~geometry,
          NA, nf_msg, FALSE, NA
        )
      }
    }
  )
}


# in theory I have caught all the errors in tryCatch above, but just in case...
check_intersect_possibly <- purrr::possibly(
  check_intersect,
  otherwise = NULL,
  quiet = FALSE
)



# check best rate to use for API calls:
# my token is limited to 20,000 calls a day
# and 100 calls a minute
day_rate <- round(60*60*24/19999, 4) # can average 1 call every 4.3203s
minute_rate <- round(60/99, 4)       # can average 1 call every 0.6061s

# this should allow jobs with >19999 requests to keep running over >24h
# without exceeding daily quota
check_intersect_slowly <- purrr::slowly(
  check_intersect_possibly,
  rate = rate_delay(pause = day_rate), # allows 19999 requests in a day
  quiet = FALSE
)

check_intersect_quite_quickly <- purrr::slowly(
  check_intersect_possibly,
  rate = rate_delay(pause = minute_rate) # uses daily quota in 1 go (max 3h22)
)




work_down <- function(current_msoa, lads_coords, slowly = FALSE, keep_sf = FALSE) {

  a <- current_msoa %>%
    sf::st_coordinates() %>%
    `[`(1,)

  coords_list <- seq(nrow(lads_coords)) %>%
    purrr::map( ~ dplyr::slice(lads_coords, .)) %>%
    purrr::map(unlist)

  if (slowly) {
    routes_df <- coords_list %>%
      purrr::map_df( ~ check_intersect_slowly(a, .))
  } else {
    routes_df <- coords_list %>%
      purrr::map_df( ~ check_intersect_quite_quickly(a, .))
  }

  # kind of pointless, but anomalies would let us know if NULLs were returned
  total_routes <- routes_df %>%
    nrow()
  crossings <- routes_df %>%
    dplyr::filter(crosses) %>%
    nrow()

  # actual errors should have been caught, then converted into valid output,
  # but with status != "Success"
  errors <- routes_df %>%
    dplyr::filter(!status == "Success") %>%
    nrow()

  usethis::ui_info(
    stringr::str_glue(
      current_msoa$msoa11cd,
      " done. Total routes: ",
      total_routes,
      ". Total crossings: ",
      crossings,
      ". Errors: ",
      errors
    )
  )


  if (keep_sf) {
    current_msoa <- current_msoa %>%
      sf::st_drop_geometry()
    routes_df %>%
      dplyr::bind_cols(., current_msoa) %>%
      dplyr::relocate(names(current_msoa)) %>%
      dplyr::mutate(
        total_results = n(),
        successful = length(which(status == "Success")),
        crossings = sum(crosses)
      ) %>%
      dplyr::select(!status) %>%
      dplyr::group_by(msoa11cd, msoa11nm, msoa11hclnm, crosses) %>%
      dplyr::summarise(
        across(total_results:crossings, mean),
        .groups = "drop"
      ) %>%
      ungroup()
  } else {
    current_msoa %>%
      dplyr::mutate(total_routes = total_routes) %>%
      dplyr::mutate(of_maximum = nrow(lads_coords)) %>%
      dplyr::mutate(crossings = crossings) %>%
      dplyr::mutate(errors = errors)
  }
}




check_full_list <- function(msoas_list, lads_list, keep_sf = FALSE) {

  slowly <- FALSE
  calls <- nrow(msoas_list) * nrow(lads_list)
  if (calls > 19999) slowly <- TRUE

  coords <- lads_list %>%
    sf::st_coordinates() %>%
    dplyr::as_tibble()

  msoas_list %>%
    split( ~ msoa11cd) %>%
    purrr::map_df( ~ work_down(., coords, slowly = slowly, keep_sf = keep_sf))
}

tmap::tmap_mode("view")
tmap::tmap_options(basemaps = "CartoDB.Positron")

# pass `keep_sf` for a sample MSOA from some UTLAs, and illustrate the
# crossings and non-crossings using tmap
plot_crossing_lines <- function(sf_df) {
  sf_df %>%
    dplyr::select(!status) %>%
    dplyr::group_by(msoa11cd, msoa11nm, msoa11hclnm, crosses) %>%
    dplyr::summarise() %>%
    ungroup() %>%
    tmap::tm_shape() +
    tmap::tm_lines(col = "crosses", palette = "Accent", lwd = 4)
}


plot_results <- function(sf_df) {
  sf_df %>%
    tmap::tm_shape() +
    tmap::tm_symbols(size = 1.2, col = "crossings", shape = 19)
}
